# Chattr: an online chat application

## Project
The aim of this project is to demonstrate the software development skills we've learned in 3813ICT by creating a web-app like Slack/Discord/Teams where users can log in, join groups, join channels, and use live chat.

## Version Control
For the development of Chattr, Github was used as the distributed version control system. This helped the project in two ways. Firstly, it acted as a backup of all work done, and made it possible to roll back to previous versions if a new feature ended up behaving unexpectedly. Secondly, it allowed for the hypothetical case where several developers might work on the project simultaneously. While there was only one developer in this case, using Github would normally make it possible for different developers to work on separate components of the project and then later merge their contributions together.

Inside the “chattr” project, there are plenty of files, most of which are automatically generated by Angular. The main directories used in the project are “server” and “src”. In a nutshell, “server” contains the back-end Javascript logic of the web application, including setting up connections to MongoDB and sockets. The “src” directory contains the actual Angular front-end components and services of the application. The “test.js” file contains unit tests for the backend. 

For each feature that was introduced, the changes to files in the local repository were committed and pushed to the master remote repository. A detailed description of the changes was provided, making it easy to roll-back to the right version of the code if necessary. A “gitignore” file meant that large folders containing node packages could be exempt from being committed to the repository, as this would have taken a long time. Even though there was only one developer working on the project, for the sake of developing a good habit, a git pull command was run each time work recommenced on the local repository. This checked for any changes to the remote version which may have taken place.

## Data Structures
On the server side, data structures are stored in a MongDB noSQL document-oriented database. The database is called “mydb” and contains collections for each main data structure: users and groups. Overall there are 4 different Typescript classes featured in the 2 collections. The 4 classes are User, Group, Room, Message. A Group can have many Rooms. A Room can have many Messages. Both Groups and Rooms contain arrays of usernames to keep track of the Users that belong to them.

- A User class contains several fields: “email”, “username”, “id”, “role” (“user” by default), “pwd” , “valid” (false by default). The username and id are both unique identifiers of a User.

- A Group class contains: “name”, “rooms” (an array of Room classes), “groupmembers” (an array of strings of usernames), “groupassis” (an array of strings of usernames). The Group name is a unique identifier.

- A Room class contains: “name”, “parent” (the name of the Group to which the Room belongs), “roommembers”, “chat” (an array of Message classes). 

- A Message class contains: “user” (the username of the message sender), “time” (the time at which the message was sent), “content”, “group” (name of the group to which it was sent), “room” (name of the room to which it was sent).



## REST API

### Routes

All of the routes do basic value checking i.e. if the body of a request is empty, the route returns a status 400.

| Route endpoint  | Description |
| ------------- | ------------- |
| /api/auth | This POST route manages the login authentication system. It determines whether or not a login attempt is allowed or not. **Parameters**: username (string), pwd (string). **Returns**: if successful, returns a User object with the “valid” field set to true. If unsuccessful, it returns a User object with the “valid” field set to false. |
| /api/addgroup | This POST route adds a new Group class to the MongoDB. It checks to see if the Group already exists or not. It uses the insertOne() MongoDB operation. **Parameters**: group (Group class). **Returns**: if successful, returns an object with the “err” field set to null. If unsuccessful because there is a duplicate group, it returns an object with the err field set to “duplicate item”. |
| /api/addgroupassis | This route adds a user as a group assistant for a group. It uses the updateOne() MongoDB operation. **Parameters**: group (Group class), groupassis (string of the username). **Returns**: if successful, returns the MongoDB return value. If unsuccessful because the user is already a group assistant, it returns an object with the “ok” field set to false. |
| /api/addmessage | This route adds a new Message to a Room’s chat history. It uses the updateOne() operation. **Parameters**: message (Message class). **Returns**: returns the MongoDB return value. |
| /api/addroom | This route adds a Room class to a Group’s list of rooms. It uses the updateOne() operation. **Parameters**: group (Group class), room (Room class). **Returns**: if successful, returns the MongoDB return value. If unsuccessful because the room already exists for the group, it returns an object with the “ok” field set to false. |
| /api/adduser | This route adds a new User class to the MongoDB users collection. It uses the insertOne() operation. **Parameters**: user (User class). **Returns**: if successful, returns an object with the “err” field set to null. If unsuccessful because there is a duplicate user, it returns an object with the err field set to “duplicate item”. |
| /api/addusergroup | This route adds a user to a group as part of its list of group members. **Parameters**: group (Group), username (string). **Returns**: if successful, returns the MongoDB return value. If unsuccessful because the user already exists for the group, it returns an object with the “ok” field set to false. |
| /api/adduserroom | This route adds a user to a room as part of its list of room members. **Parameters**: room (Room), username (string). **Returns**: if successful, returns the MongoDB return value. If unsuccessful because the user already exists for the room, it returns an object with the “ok” field set to false. |
| /api/deletegroup | This route deletes a group from the groups collection in MongoDB. It uses the deleteOne() operation. **Parameters**: group (Group). **Returns**: if successful, returns the MongoDB return value. |
| /api/deleteroom | This route deletes a room from a group in MongoDB. **Parameters**: group (Group). **Returns**: if successful, returns the MongoDB return value. |
| /api/deleteuser | This route deletes a user from the users collection in MongoDB. **Parameters**: user (User). **Returns**: if successful, returns the MongoDB return value. |
| /api/getgroups | This GET route retrieves all groups from the groups collection in MongoDB. **Parameters**: none. **Returns**: an array of Group classes. |
| /api/getusers | This GET route retrieves all users from the users collection in MongoDB. **Parameters**: none. **Returns**: an array of User classes. |
| /api/removegroupassis | This POST route removes a group assistant from the list of group assistants for a group. **Parameters**: group (Group), groupassis (string). **Returns**: if successful, returns the MongoDB return value. |
| /api/removeusergroup | This POST route removes a user from a group and its associated rooms. **Parameters**: group (Group), username (string). **Returns**: if successful, returns the MongoDB return value. |
| /api/removeuserroom | This POST route removes a user from a room. **Parameters**: room (Room), username (string). **Returns**: if successful, returns the MongoDB return value. |
| /api/updateuser | This POST route updates the details for a user. **Parameters**: user (User). **Returns**:  if successful, returns the MongoDB return value. |


## Angular architecture 

### Components
Four components were created to manage user interactions on the front-end: Login, Manage, Update, Livechat.

**Login**: this component exists at the “/login” path and it handles authentication. Through the “login.component.html” template, it provides a form for the user to enter their details and then logs the user in if the details are correct. When a user submits their details, the itemClicked() function is triggered. This function exists in “login.component.ts” and calls the AuthService login() function, which calls the “/api/auth” endpoint to verify if the user exists or not. If the user doesn’t exist, an alert appears in the browser. If the user does exist, the user’s details are then saved into local sessionStorage by the itemClicked() function.

**Manage**: this component exists at the “/manage” path and handles most of the web app’s CRUD operations. Depending on a user’s “role” (superadmin, groupadmin, groupassis), different operations can be performed. In the Manage component, there is a list of users, and it’s possible to create, update and delete users. There is a list of groups, and it’s possible to create, update and delete groups. Users can be added or removed from groups and rooms. Rooms can be added or removed from groups. Users in a group can be appointed as group assistants too. These options are made available through forms in the “manage.component.html” template. Submitting a form triggers a function in “manage.component.ts”, which calls a function in AuthService. These functions then make API calls to the various routes listed earlier in the report. Upon initialisation, the Manage component tries to retrieve the “current user” from session storage. This determines which view of forms should be displayed, based on the user’s role and their permissions. Various Angular templating statements are used to make the view dynamic. If a user is not logged in, then the component redirects them to the “/login” route.

**Update**: this component exists at the “/update” path and provides a way to edit a user’s details. Everything about the user can be edited, except for their unique ID. To access the page, a superadmin has to click the “Edit” button on a user’s profile from the Manage page. On the template side, “update.component.html” provides a form pre-filled with the selected user’s details (which have been stored in localStorage). The details can be changed and then the submitted form triggers a function called editUser() in “update.component.ts” which calls the API via AuthService. Submitting the form redirects the user to the “/manage” route.

**Livechat**: this component exists at the “/livechat” path and provides a place for users to see groups and rooms they belong to, and engage in live chat with other members. Upon loading the page, the SocketService is called to initialise a socket connection on the server side. The template, “livechat.component.html”, features a small form where the user can choose a group they belong to and then choose a room they belong to in the group. By submitting the form, a function in “livechat.component.ts” calls the API and returns the chat history for that room. A user can then use another form to send messages to the room chat, using sockets. This component uses a separate SocketService to manage its interactions with the API and the sockets service. The socket connection means that new messages come in real time.

### Services
The benefit of using an Angular service is that all of the functions which interface with the API are stored in one spot. It also makes it easy to call the same functions from different components. Two services were used in the project: AuthService and SocketService.

**AuthService**: this service handles the majority of data-related functions. There are 16 functions which refer to 16 of the API endpoints, allowing for a variety of CRUD operations on Users, Groups and Rooms. There is also a login function to handle authentication.

**SocketService**: this service is reserved for the Livechat component, which uses functions to interact with the socket connection. The initSocket() function starts the socket connection on the server side. There are then two functions, onMessage() and onStatus() which use Observables to constantly poll the socket connection and bring in any new data. The functions send() and sendStatus() send data from the user side to the other socket connections. There is also a standard API call which adds messages to MongoDB.

### Models
Four models were created to handle the main data structures, as indicated earlier. The models are “user.ts” (containing the User class), “group.ts” (containing the Group class), “room.ts” (containing the Room class), and “message.ts” (containing the Message class).


## Client-server architecture
The responsibilities of both the client and the server are divided in such a way so as to let the server handle the update and retrieval of data, while the client acts as the portal through which requests go to the server. More specifically, the client contains functions which interface with the application’s front-end. Certain actions trigger functions, which are then redirected via the AuthService to their respective routes on the back-end. The back-end, or server, contains logic which interacts with the MongoDB database and returns the data requested by the client.

Angular components are updated by having their values bound to values variables within the respective component. In input forms, for example, the “banana in a box” notation is used to link field values to variables, which can then pass on the input. Likewise, to display a variable in the HTML front-end, curly braces are used to embed the updateable variable in the web page.

## Unit tests
Unit tests are provided for the routes on the server side. In total there are 18 tests, testing 75% of the back-end routes.

**Before running tests, disable CORS settings in `server.js`**. Run the unit tests with `npm test`.