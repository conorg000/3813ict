# Chattr: an online chat application

## Project
The aim of this project is to demonstrate the software development skills we've learned in 3813ICT by creating a web-app like Slack/Discord/Teams where users can log in, join groups, join channels, and use live chat.

## Version Control
For the development of Chattr, Github was used as the distributed version control system. This helped the project in two ways. Firstly, it acted as a backup of all work done, and made it possible to roll back to previous versions if a new feature ended up behaving unexpectedly. Secondly, it allowed for the hypothetical case where several developers might work on the project simultaneously. While there was only one developer in this case, using Github would normally make it possible for different developers to work on separate components of the project and then later merge their contributions together.

Inside the “chattr” project, there are plenty of files, most of which are automatically generated by Angular. The main directories used in the project are “server” and “src”. In a nutshell, “server” contains the back-end Javascript logic of the web application, including setting up connections to MongoDB and sockets. The “src” directory contains the actual Angular front-end components and services of the application. The “test.js” file contains unit tests for the backend. 

For each feature that was introduced, the changes to files in the local repository were committed and pushed to the master remote repository. A detailed description of the changes was provided, making it easy to roll-back to the right version of the code if necessary. A “gitignore” file meant that large folders containing node packages could be exempt from being committed to the repository, as this would have taken a long time. Even though there was only one developer working on the project, for the sake of developing a good habit, a git pull command was run each time work recommenced on the local repository. This checked for any changes to the remote version which may have taken place.

## Data Structures
On the server side, data structures are stored in a MongDB noSQL document-oriented database. The database is called “mydb” and contains collections for each main data structure: users and groups. Overall there are 4 different Typescript classes featured in the 2 collections. The 4 classes are User, Group, Room, Message. A Group can have many Rooms. A Room can have many Messages. Both Groups and Rooms contain arrays of usernames to keep track of the Users that belong to them.

- A User class contains several fields: “email”, “username”, “id”, “role” (“user” by default), “pwd” , “valid” (false by default). The username and id are both unique identifiers of a User.

- A Group class contains: “name”, “rooms” (an array of Room classes), “groupmembers” (an array of strings of usernames), “groupassis” (an array of strings of usernames). The Group name is a unique identifier.

- A Room class contains: “name”, “parent” (the name of the Group to which the Room belongs), “roommembers”, “chat” (an array of Message classes). 

- A Message class contains: “user” (the username of the message sender), “time” (the time at which the message was sent), “content”, “group” (name of the group to which it was sent), “room” (name of the room to which it was sent).



## REST API

### Routes

All of the routes do basic value checking i.e. if the body of a request is empty, the route returns a status 400.

| Route endpoint  | Description |
| ------------- | ------------- |
| /api/auth | This POST route manages the login authentication system. It determines whether or not a login attempt is allowed or not.
- Parameters: username (string), pwd (string)
- Returns: if successful, returns a User object with the “valid” field set to true. If unsuccessful, it returns a User object with the “valid” field set to false. |
| /api/addgroup | This POST route adds a new Group class to the MongoDB. It checks to see if the Group already exists or not. It uses the insertOne() MongoDB operation.
- Parameters: group (Group class)
- Returns: if successful, returns an object with the “err” field set to null. If unsuccessful because there is a duplicate group, it returns an object with the err field set to “duplicate item”. |

/api/addgroupassis
This route adds a user as a group assistant for a group. It uses the updateOne() MongoDB operation.
Parameters: group (Group class), groupassis (string of the username)
Returns: if successful, returns the MongoDB return value. If unsuccessful because the user is already a group assistant, it returns an object with the “ok” field set to false.
/api/addmessage
This route adds a new Message to a Room’s chat history. It uses the updateOne() operation.
Parameters: message (Message class)
Returns: returns the MongoDB return value.
/api/addroom
This route adds a Room class to a Group’s list of rooms. It uses the updateOne() operation.
Parameters: group (Group class), room (Room class)
Returns: if successful, returns the MongoDB return value. If unsuccessful because the room already exists for the group, it returns an object with the “ok” field set to false.
/api/adduser
This route adds a new User class to the MongoDB users collection. It uses the insertOne() operation.
Parameters: user (User class)
Returns: if successful, returns an object with the “err” field set to null. If unsuccessful because there is a duplicate user, it returns an object with the err field set to “duplicate item”.
/api/addusergroup
This route adds a user to a group as part of its list of group members.
Parameters: group (Group), username (string)
Returns: if successful, returns the MongoDB return value. If unsuccessful because the user already exists for the group, it returns an object with the “ok” field set to false.
/api/adduserroom
This route adds a user to a room as part of its list of room members.
Parameters: room (Room), username (string)
Returns: if successful, returns the MongoDB return value. If unsuccessful because the user already exists for the room, it returns an object with the “ok” field set to false.
/api/deletegroup
This route deletes a group from the groups collection in MongoDB. It uses the deleteOne() operation.
Parameters: group (Group)
Returns: if successful, returns the MongoDB return value.
/api/deleteroom
This route deletes a room from a group in MongoDB.
Parameters: group (Group)
Returns: if successful, returns the MongoDB return value.
/api/deleteuser
This route deletes a user from the users collection in MongoDB.
Parameters: user (User)
Returns: if successful, returns the MongoDB return value.
/api/getgroups
This GET route retrieves all groups from the groups collection in MongoDB.
Parameters: none
Returns: an array of Group classes.
/api/getusers
This GET route retrieves all users from the users collection in MongoDB.
Parameters: none
Returns: an array of User classes.
/api/removegroupassis
This POST route removes a group assistant from the list of group assistants for a group.
Parameters: group (Group), groupassis (string)
Returns: if successful, returns the MongoDB return value.
/api/removeusergroup
This POST route removes a user from a group and its associated rooms.
Parameters: group (Group), username (string)
Returns: if successful, returns the MongoDB return value.
/api/removeuserroom
This POST route removes a user from a room.
Parameters: room (Room), username (string)
Returns: if successful, returns the MongoDB return value.
/api/updateuser
This POST route updates the details for a user.
Parameters: user (User)
Returns:  if successful, returns the MongoDB return value


### Components
Three components were created: Account, Chat, Login.

The Chat component was designed to host the communications for a group’s room. For the given user, it fetches the groups that the user is a part of and the rooms that they’ve joined. With those details displayed, it allows the user to choose a room and view the chat. It communicates with the AuthService. On initialisation, if a user is logged in, it calls the userGroups and groupData functions and routes to retrieve data on the current user’s group and rooms. When a room is selected and clicked, the seeChat function fires. This then displays the chat history for the selected room. If the user wants to send a message, the submit button triggers the sendMsg function which ends up writing the new message to the JSON file.

The Login component handles authentication. It provides a form for the user to enter their details and then logs the user in if the details are correct. It communicates with the AuthService. When a user submits their details, the itemClicked function is triggered. This verifies if the user exists or not.

The Account component was designed to be a place for users to edit their details, and for admins to edit users and groups. Unfortunately, this didn’t get completed in this phase of the assignment. The plan would be to have a form which allows the administrator to add/remove users to/from groups and rooms. The new configuration would then be saved to the “database.json”.

### Services and Routes
The AuthService acts as a gateway to the key API routes used by the various components. It contains four routes:
- http://localhost:3000/api/auth for the login function
- http://localhost:3000/api/userdata for the userData function
- http://localhost:3000/api/groupdata for the groupData function
- http://localhost:3000/api/sendmsg for the sendMsg function

## Node Server Architecture

### Modules and Functions
In the api-login.js file, there is a post function for each API route in the AuthService. 
- “/api/auth” is an authentication procedure called by the Login component. It loops through the existing users in “database.json” to see if any of the user objects match the submitted email and password combination.
- “/api/userdata” is a method which retrieves the group data for a logged in user (which groups they are signed up for, and which rooms).
- “/api/groupdata” is a method which retrieves all the group information and room chat history.
- “/api/sendmsg” is a method which adds a message object to the existing chat history for a room. It takes the submitted message and the sender’s username and pushes them to the array of messages in the “database.json”.

Modules used in server.js on the server side include Express, Body Parser, Path, Http, and Cors.

### Files
There is a single file containing all of the initial serialised JSON data, “database.json”. The JSON file is read by API routes and then parsed to load the necessary data. If changes are made which require updating the data, the changes are made and then saved over the existing file.

## Client-server Architecture
The responsibilities of both the client and the server are divided in such a way so as to let the server handle the update and retrieval of data, while the client acts as the portal through which requests go to the server. More specifically, the client contains functions which interface with the application’s front-end. Certain actions trigger functions, which are then redirected via the AuthService to their respective routes on the back-end. The back-end, or server, contains logic which returns the data requested by the client.

## Client-server interaction
As described earlier, actions triggered on the client side lead the server to supply, modify or update the data. This happens by reading and writing to the serialised JSON file “database.json” with functions like 

Angular components are updated by having their values bound to values variables within the respective component. In input forms, for example, the “banana in a box” notation is used to link field values to variables, which can then pass on the input. Likewise, to display a variable in the HTML front-end, curly braces are used to embed the updateable variable in the web page.
